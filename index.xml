<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Qbec</title>
    <link>http://qbec.io/</link>
    <description>Recent content in Home on Qbec</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://qbec.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>A quick tour of qbec</title>
      <link>http://qbec.io/userguide/tour/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/userguide/tour/</guid>
      <description>Initialize a new qbec app qbec provides an init command to set up a new application. Let&amp;rsquo;s run this and see what happens.
qbec init demo --with-example # --with-example creates a sample &amp;quot;hello&amp;quot; component  When the above command runs successfully, it creates a subdirectory called demo that has a single component and environment. The default environment is inferred from the current context in your kube config.
The following files are created in the demo directory:</description>
    </item>
    
    <item>
      <title>Folders, files, parameters</title>
      <link>http://qbec.io/userguide/usage/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/userguide/usage/basic/</guid>
      <description>At the very least, you need to have the following files and folders for a qbec app:
 qbec.yaml - this needs to be at the root of the source directory and defines your application in terms of:  supported environments components that should be excluded by default for all environments specific components excluded and included in specific environments. See the reference document for more details.  a folder for components.</description>
    </item>
    
    <item>
      <title>Create components</title>
      <link>http://qbec.io/userguide/usage/authoring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/userguide/usage/authoring/</guid>
      <description>qbec supports components written as YAML, JSON or jsonnet files. YAML and JSON documents are static and unable to support parameterization per environment. These formats are good enough for Kubernetes objects like roles, role bindings, service accounts etc. where the content doesn&amp;rsquo;t usually vary per environment. In order to create components that need to be different per environment, you are pretty much required to use jsonnet.
Component structure Components are loaded from the components directory defined for your app.</description>
    </item>
    
    <item>
      <title>Common object metadata</title>
      <link>http://qbec.io/userguide/usage/common-metadata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/userguide/usage/common-metadata/</guid>
      <description>qbec provides an easy mechanism to set up common metadata like annotations for all objects produced. For example, you may want to set up a team annotation for all objects.
You do this by defining a post-processor. A post-processor is a jsonnet file that contains a single function like so:
// the post processor jsonnet must return a function taking exactly one parameter // called &amp;quot;object&amp;quot; and returning its decorated version.</description>
    </item>
    
    <item>
      <title>Core concepts</title>
      <link>http://qbec.io/userguide/model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/userguide/model/</guid>
      <description>qbec uses the following concepts.
Components Components are the source code that you write that represent Kubernetes objects. You will typically organize related Kubernetes objects as a single component (e.g. a microservice that needs a service account, deployment, service, and config map kubernetes objects).
Components are loaded from jsonnet, json, or yaml files. Only jsonnet files provide the ability to customize object definitions for different environments. In addition, qbec support loading objects from helm charts, and using jsonnet libraries to produce them.</description>
    </item>
    
    <item>
      <title>Runtime parameters</title>
      <link>http://qbec.io/userguide/usage/runtime-params/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/userguide/usage/runtime-params/</guid>
      <description>Runtime parameters are values that differ across environments, change over time, or are secrets that should not be casually revealed.
Properties like replicas of a deployment per environment, cluster level endpoints etc. are usually known in advance and should be checked into source code.
Some parameters cannot be checked into source code. These include tags for images produced by a CI build whose value should be subsequently used in the same build for a deployment, environment-specific secrets, etc.</description>
    </item>
    
    <item>
      <title>Branch builds and CI</title>
      <link>http://qbec.io/userguide/usage/branches-and-ci/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/userguide/usage/branches-and-ci/</guid>
      <description>You have created jsonnet components, a qbec.yaml file and declared a dev environment. These are good enough for local development and/ or commits to a master branch. Now you are looking for a way to create objects with slightly different names as part of functional tests of your pull request builds.
You want to ensure that each branch build runs in its own &amp;ldquo;scope&amp;rdquo; and does not interfere with your master builds.</description>
    </item>
    
    <item>
      <title>Controlling qbec behavior</title>
      <link>http://qbec.io/userguide/usage/directives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/userguide/usage/directives/</guid>
      <description>qbec usually does the right thing when applying objects. Sometimes this behavior needs tweaking. Qbec allows you to annotate objects with specific directives to control its behavior. All annotations are in the directives.qbec.io/ namespace.
Updating and deleting objects Usually qbec will update and delete objects as required. You can &amp;ldquo;lock&amp;rdquo; objects from being updated or deleted using the following annotations:
 directives.qbec.io/update-policy: never directives.qbec.io/delete-policy: never  The first is useful when dealing with jobs that typically should not be updated.</description>
    </item>
    
    <item>
      <title>Running qbec commands</title>
      <link>http://qbec.io/userguide/usage/commands/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/userguide/usage/commands/</guid>
      <description>The qbec CLI provides usage help for all commands. The commands that qbec supports are:
$ qbec --help qbec provides a set of commands to manage kubernetes objects on multiple clusters. Usage: qbec [command] Available Commands: alpha experimental qbec commands apply apply one or more components to a Kubernetes cluster completion Output shell completion for bash component component lists and diffs delete delete one or more components from a Kubernetes cluster diff diff one or more components against objects in a Kubernetes cluster env environment lists and details eval evaluate the supplied file optionally under a qbec environment fmt format jsonnet, yaml or json files help Help about any command init initialize a qbec app param parameter lists and diffs show show output in YAML or JSON format for one or more components validate validate one or more components against the spec of a kubernetes cluster version print program version .</description>
    </item>
    
    <item>
      <title>Tips and tricks</title>
      <link>http://qbec.io/userguide/usage/tips-and-tricks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/userguide/usage/tips-and-tricks/</guid>
      <description>Runtime  qbec is written to have good performance even when dealing with hundreds of objects. That said, this is wholly dependent on how long a basic command like qbec show takes to execute. Most of the time taken by qbec show is in component evaluation, which in turn is dependent on the performance of jsonnet libraries that your components use. A good rule of thumb is that you will have an enjoyable experience with qbec if qbec show executes in less than a second or two and a poorer experience otherwise.</description>
    </item>
    
    <item>
      <title>Application YAML</title>
      <link>http://qbec.io/reference/qbec-yaml/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/reference/qbec-yaml/</guid>
      <description>The app configuration is a file called qbec.yaml and needs to be at the root of the directory tree.
apiVersion: qbec.io/v1alpha1 # only supported version currently kind: App # must always be &amp;quot;App&amp;quot; metadata: name: my-app # app name. Allows multiple qbec apps to deploy different objects to the same namespace without GC collisions spec: componentsDir: components # directory where component files can be found. Not recursive. default: components paramsFile: params.</description>
    </item>
    
    <item>
      <title>Qbec directives</title>
      <link>http://qbec.io/reference/directives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/reference/directives/</guid>
      <description>Annotations that you can use for your objects to control qbec behavior.
directives.qbec.io/apply-order  Annotation source: local object Allowed values: Any positive integer as a string (i.e. ensure that the value is quoted in YAML) Default value: &amp;quot;0&amp;quot; (use qbec defaults)  controls the order in which objects are applied. This allows you, for example, to move updates of a custom resource to after all other objects have been processed.</description>
    </item>
    
    <item>
      <title>Standard jsonnet variables</title>
      <link>http://qbec.io/reference/jsonnet-vars/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/reference/jsonnet-vars/</guid>
      <description>qbec exposes the following standard jsonnet variables whenever it evaluates components.
 qbec.io/env - the name of the environment for which processing occurs. qbec.io/envProperties - the properties associated with the environment if present or an empty object. For the baseline environment (_), this is set to the baseProperties object define in qbec.yaml. qbec.io/tag - the tag specified for the command using the --app-tag option. qbec.io/defaultNs - the default namespace in use.</description>
    </item>
    
    <item>
      <title>Metadata for K8s objects</title>
      <link>http://qbec.io/reference/gen-metadata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/reference/gen-metadata/</guid>
      <description>Labels All Kubernetes objects produced by qbec have the following labels associated with them:
 qbec.io/application - the app name from qbec.yaml. qbec.io/environment - the environment name in qbec.yaml for which the object was created. qbec.io/tag - the --app-tag parameter passed in on the command line. This label is only set when non-blank.  The labels are used to efficiently find all cluster objects for a specific app and environment (and tag, if specified) for garbage collection.</description>
    </item>
    
    <item>
      <title>Jsonnet native functions</title>
      <link>http://qbec.io/reference/jsonnet-native-funcs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/reference/jsonnet-native-funcs/</guid>
      <description>A list of all native functions that qbec natively supports.
expandHelmTemplate this function is now deprecated. Integrate with helm using external data sources instead
The expandHelmTemplate function expands a helm chart and returns the resulting objects. This is EXPERIMENTAL in nature - the API is subject to change in a subsequent release. It runs the helm template command, assuming that the helm binary is already installed and available in the PATH.</description>
    </item>
    
    <item>
      <title>Jsonnet glob importer</title>
      <link>http://qbec.io/reference/jsonnet-glob-importer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/reference/jsonnet-glob-importer/</guid>
      <description>In many situations it is useful to be able to import a bag of files as an object. For instance, it is convenient to load all environment configuration files present with a single invocation to import to pick up all files found without having to name them individually.
For this purpose, qbec supplies a glob importer for importing a bag of files using a glob pattern. It supports two variants, one for importing the files that match the glob as code and another for importing the files as a string (suitable, for example, for YAML files).</description>
    </item>
    
    <item>
      <title>Jsonnet data importer</title>
      <link>http://qbec.io/reference/jsonnet-external-data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/reference/jsonnet-external-data/</guid>
      <description>Sometimes you need to generate data using external programs and be able to access it in your jsonnet components. This can be accomplished using the data source importer that ships with qbec.
While the design of the importer allows for tight, native integration with tools like helm, istioctl, kustomize, and secret engines like vault, the only integration that is currently implemented is exec that allows you to run external programs and use the standard output they produce as data in jsonnet code.</description>
    </item>
    
    <item>
      <title>Component evaluation</title>
      <link>http://qbec.io/reference/component-evaluation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/reference/component-evaluation/</guid>
      <description>How qbec evaluates component code using jsonnet and what it expects the output to look like.
Component loading  Consider every .jsonnet, .json, and .yaml file directly under the component directory as a component to be loaded. In this case, the component name is the file name without the extension. Check immediate subdirectories of the component directory to see if they contain an index.jsonnet or index.yaml file. If so, create a component with the sub-directory name.</description>
    </item>
    
    <item>
      <title>Diffs and patches</title>
      <link>http://qbec.io/reference/diffs-and-patches/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/reference/diffs-and-patches/</guid>
      <description>qbec uses a 3-way merge patch similar to kubectl/ksonnet apply. The Kubernetes documentation describes how this works.
For existing objects, the qbec diff command produces a diff between the last applied configuration stored on the server and the current configuration of the object loaded from source. This diff is &amp;ldquo;clean&amp;rdquo; in the sense of the remote object not having additional fields, default values and so on. It faithfully represents the change between the previous and current version of the object produced from source code.</description>
    </item>
    
    <item>
      <title>Garbage collection</title>
      <link>http://qbec.io/reference/garbage-collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://qbec.io/reference/garbage-collection/</guid>
      <description>While garbage collection is supported as a first-class operation qbec and enabled by default, it is a complex, nuanced subject fraught with special cases. We hope that the explanation below can help users figure out the causes of issues they might see in this area and create better bug reports.
What garbage collection means Garbage collection is the act of deleting objects that were once applied for a qbec app but no longer exist in source code.</description>
    </item>
    
  </channel>
</rss>